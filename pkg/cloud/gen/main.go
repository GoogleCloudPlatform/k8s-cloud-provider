/*
Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Generator for GCE compute wrapper code. You must regenerate the code after
// modifying this file:
//
//	$ go run gen/main.go > gen.go
package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"text/template"
	"time"

	"github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud/meta"
)

const (
	gofmt                      = "gofmt"
	packageRoot                = "github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud"
	googleAPIPackage           = "google.golang.org/api/googleapi"
	kLogPackage                = "k8s.io/klog/v2"
	alphaComputePackage        = "google.golang.org/api/compute/v0.alpha"
	betaComputePackage         = "google.golang.org/api/compute/v0.beta"
	gaComputePackage           = "google.golang.org/api/compute/v1"
	betaNetworkServicesPackage = "google.golang.org/api/networkservices/v1beta1"
	gaNetworkServicesPackage   = "google.golang.org/api/networkservices/v1"
	kLogEnabled                = ".Enabled()"

	filterPackage = packageRoot + "/filter"
	metaPackage   = packageRoot + "/meta"

	// readOnly specifies that the given resource is read-only and should not
	// have insert() or delete() methods generated for the wrapper.
	readOnly = iota
)

var flags = struct {
	gofmt bool
	mode  string
}{}

func init() {
	flag.BoolVar(&flags.gofmt, "gofmt", true, "run output through gofmt")
	flag.StringVar(&flags.mode, "mode", "src", "content to generate: src, test, dummy")
}

// gofmtContent runs "gofmt" on the given contents.
func gofmtContent(r io.Reader) string {
	cmd := exec.Command(gofmt, "-s")
	out := &bytes.Buffer{}
	cmd.Stdin = r
	cmd.Stdout = out
	cmdErr := &bytes.Buffer{}
	cmd.Stderr = cmdErr

	if err := cmd.Run(); err != nil {
		fmt.Fprintf(os.Stderr, cmdErr.String())
		panic(err)
	}
	return out.String()
}

// genHeader generate the header for the file.
func genHeader(wr io.Writer) {
	const text = `/*
Copyright {{.Year}} Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was generated by "go run gen/main.go > gen.go". Do not edit
// directly.

package cloud

import (
	"context"
	"fmt"
	"net/http"
	"sync"

	"{{.GoogleAPIPackage}}"
	"{{.KLogPackage}}"

	"{{.FilterPackage}}"
	"{{.MetaPackage}}"

`
	tmpl := template.Must(template.New("header").Parse(text))
	values := map[string]string{
		"Year":             fmt.Sprintf("%v", time.Now().Year()),
		"GoogleAPIPackage": googleAPIPackage,
		"KLogPackage":      kLogPackage,
		"FilterPackage":    filterPackage,
		"MetaPackage":      metaPackage,
	}
	if err := tmpl.Execute(wr, values); err != nil {
		panic(err)
	}

	var hasComputeGA, hasComputeAlpha, hasComputeBeta bool
	var hasNetworkServicesGA, hasNetworkServicesBeta bool
	for _, s := range meta.AllServices {
		switch {
		case s.APIGroup == meta.APIGroupCompute && s.Version() == meta.VersionAlpha:
			hasComputeAlpha = true
		case s.APIGroup == meta.APIGroupCompute && s.Version() == meta.VersionBeta:
			hasComputeBeta = true
		case s.APIGroup == meta.APIGroupCompute && s.Version() == meta.VersionGA:
			hasComputeGA = true
		case s.APIGroup == meta.APIGroupNetworkServices && s.Version() == meta.VersionBeta:
			hasNetworkServicesBeta = true
		case s.APIGroup == meta.APIGroupNetworkServices && s.Version() == meta.VersionGA:
			hasNetworkServicesGA = true
		}
	}

	if hasComputeAlpha {
		fmt.Fprintf(wr, "	computealpha \"%s\"\n", alphaComputePackage)
	}
	if hasComputeBeta {
		fmt.Fprintf(wr, "	computebeta \"%s\"\n", betaComputePackage)
	}
	if hasComputeGA {
		fmt.Fprintf(wr, "	computega \"%s\"\n", gaComputePackage)
	}
	if hasNetworkServicesBeta {
		fmt.Fprintf(wr, "	networkservicesbeta \"%s\"\n", betaNetworkServicesPackage)
	}
	if hasNetworkServicesGA {
		fmt.Fprintf(wr, "	networkservicesga \"%s\"\n", gaNetworkServicesPackage)
	}

	fmt.Fprintf(wr, ")\n\n")

	const kLogAdapter = `

func kLogEnabled(level klog.Level) bool {
	return klog.V(level){{.KLogEnabled}} == true
}

`

	kLogAdapterTemplate := template.Must(template.New("klogadapter").Parse(kLogAdapter))
	kLogTemplateValues := map[string]string{
		"KLogEnabled": kLogEnabled,
	}
	if err := kLogAdapterTemplate.Execute(wr, kLogTemplateValues); err != nil {
		panic(err)
	}
}

// genStubs generates the interface and wrapper stubs.
func genStubs(wr io.Writer) {
	const text = `// Cloud is an interface for the GCE compute API.
type Cloud interface {
{{- range .All}}
	{{.WrapType}}() {{.WrapType}}
{{- end}}
}

// NewGCE returns a GCE.
func NewGCE(s *Service) *GCE {
	g := &GCE{
	{{- range .All}}
		{{.Field}}: &{{.GCPWrapType}}{s},
	{{- end}}
	}
	return g
}

// GCE implements Cloud.
var _ Cloud = (*GCE)(nil)

// GCE is the golang adapter for the compute APIs.
type GCE struct {
{{- range .All}}
	{{.Field}} *{{.GCPWrapType}}
{{- end}}
}

{{range .All}}
// {{.WrapType}} returns the interface for the {{.Version}} {{.Service}}.
func (gce *GCE) {{.WrapType}}() {{.WrapType}} {
	return gce.{{.Field}}
}
{{- end}}

// NewMockGCE returns a new mock for GCE.
func NewMockGCE(projectRouter ProjectRouter) *MockGCE {
	{{- range .Groups}}
	mock{{.Service}}Objs := map[meta.Key]*Mock{{.Service}}Obj{}
	{{- end}}

	mock := &MockGCE{
	{{- range .All}}
		{{.MockField}}: New{{.MockWrapType}}(projectRouter, mock{{.Service}}Objs),
	{{- end}}
	}
	return mock
}

// MockGCE implements Cloud.
var _ Cloud = (*MockGCE)(nil)

// MockGCE is the mock for the compute API.
type MockGCE struct {
{{- range .All}}
	{{.MockField}} *{{.MockWrapType}}
{{- end}}
}
{{range .All}}
// {{.WrapType}} returns the interface for the {{.Version}} {{.Service}}.
func (mock *MockGCE) {{.WrapType}}() {{.WrapType}} {
	return mock.{{.MockField}}
}
{{end}}

{{range .Groups}}
// Mock{{.Service}}Obj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type Mock{{.Service}}Obj struct {
	Obj interface{}
}
{{- if .HasAlpha}}
// ToAlpha retrieves the given version of the object.
func (m *Mock{{.Service}}Obj) ToAlpha() *{{.Alpha.FQObjectType}} {
	if ret, ok := m.Obj.(*{{.Alpha.FQObjectType}}); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &{{.Alpha.FQObjectType}}{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *{{.Alpha.FQObjectType}} via JSON: %v", m.Obj, err)
	}
	return ret
}
{{- end}}
{{- if .HasBeta}}
// ToBeta retrieves the given version of the object.
func (m *Mock{{.Service}}Obj) ToBeta() *{{.Beta.FQObjectType}} {
	if ret, ok := m.Obj.(*{{.Beta.FQObjectType}}); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &{{.Beta.FQObjectType}}{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *{{.Beta.FQObjectType}} via JSON: %v", m.Obj, err)
	}
	return ret
}
{{- end}}
{{- if .HasGA}}
// ToGA retrieves the given version of the object.
func (m *Mock{{.Service}}Obj) ToGA() *{{.GA.FQObjectType}} {
	if ret, ok := m.Obj.(*{{.GA.FQObjectType}}); ok {
		return ret
	}
		// Convert the object via JSON copying to the type that was requested.
	ret := &{{.GA.FQObjectType}}{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *{{.GA.FQObjectType}} via JSON: %v", m.Obj, err)
	}
	return ret
}
{{- end}}
{{- end}}
`
	data := struct {
		All    []*meta.ServiceInfo
		Groups map[string]*meta.ServiceGroup
	}{meta.AllServices, meta.AllServicesByGroup}

	tmpl := template.Must(template.New("interface").Parse(text))
	if err := tmpl.Execute(wr, data); err != nil {
		panic(err)
	}
}

// callOperationRequiresID returns true if the ServiceInfo.Object is
// of a particular type.
func callOperationRequiresID(obj string) bool {
	switch obj {
	case "TcpRoute", "GrpcRoute", "HttpRoute", "TlsRoute", "EndpointPolicy",
		"Gateway", "Mesh", "ServiceBinding":
		return true
	}
	return false
}

// genTypes generates the type wrappers.
func genTypes(wr io.Writer) {

	const text = `// {{.WrapType}} is an interface that allows for mocking of {{.Service}}.
type {{.WrapType}} interface {
{{- if .GenerateCustomOps}}
	// {{.WrapTypeOps}} is an interface with additional non-CRUD type methods.
	// This interface is expected to be implemented by hand (non-autogenerated).
	{{.WrapTypeOps}}
{{- end}}
{{- if .GenerateGet}}
	Get(ctx context.Context, key *meta.Key, options... Option) (*{{.FQObjectType}}, error)
{{- end -}}
{{- if .GenerateList}}
{{- if .KeyIsGlobal}}
	List(ctx context.Context, fl *filter.F, options... Option) ([]*{{.FQObjectType}}, error)
{{- end -}}
{{- if .KeyIsRegional}}
	List(ctx context.Context, region string, fl *filter.F, options... Option) ([]*{{.FQObjectType}}, error)
{{- end -}}
{{- if .KeyIsZonal}}
	List(ctx context.Context, zone string, fl *filter.F, options... Option) ([]*{{.FQObjectType}}, error)
{{- end -}}
{{- end -}}
{{- if .GenerateInsert}}
	Insert(ctx context.Context, key *meta.Key, obj *{{.FQObjectType}}, options... Option) error
{{- end -}}
{{- if .GenerateDelete}}
	Delete(ctx context.Context, key *meta.Key, options... Option) error
{{- end -}}
{{- if .AggregatedList}}
	AggregatedList(ctx context.Context, fl *filter.F, options... Option) (map[string][]*{{.FQObjectType}}, error)
{{- end}}
{{- if .ListUsable}}
	ListUsable(ctx context.Context, fl *filter.F, options... Option) ([]*{{.FQListUsableObjectType}}, error)
{{- end}}
{{- with .Methods -}}
{{- range .}}
	{{.InterfaceFunc}}
{{- end -}}
{{- end}}
}

// New{{.MockWrapType}} returns a new mock for {{.Service}}.
func New{{.MockWrapType}}(pr ProjectRouter, objs map[meta.Key]*Mock{{.Service}}Obj) *{{.MockWrapType}} {
	mock := &{{.MockWrapType}}{
		ProjectRouter: pr,

		Objects: objs,
		{{- if .GenerateGet}}
		GetError:    map[meta.Key]error{},
		{{- end -}}
		{{- if .GenerateInsert}}
		InsertError: map[meta.Key]error{},
		{{- end -}}
		{{- if .GenerateDelete}}
		DeleteError: map[meta.Key]error{},
		{{- end}}
	}
	return mock
}

// {{.MockWrapType}} is the mock for {{.Service}}.
type {{.MockWrapType}} struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*Mock{{.Service}}Obj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	{{- if .GenerateGet}}
	GetError map[meta.Key]error
	{{- end -}}
	{{- if .GenerateList}}
	ListError *error
	{{- end -}}
	{{- if .GenerateInsert}}
	InsertError map[meta.Key]error
	{{- end -}}
	{{- if .GenerateDelete}}
	DeleteError map[meta.Key]error
	{{- end -}}
	{{- if .AggregatedList}}
	AggregatedListError *error
	{{- end}}
	{{- if .ListUsable}}
	ListUsableError *error
	{{- end}}

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	{{- if .GenerateGet}}
	GetHook    func(ctx context.Context, key *meta.Key, m *{{.MockWrapType}}, options ...Option) (bool, *{{.FQObjectType}}, error)
	{{- end -}}
	{{- if .GenerateList}}
	{{- if .KeyIsGlobal}}
	ListHook   func(ctx context.Context, fl *filter.F, m *{{.MockWrapType}}, options ...Option) (bool, []*{{.FQObjectType}}, error)
	{{- end -}}
	{{- if .KeyIsRegional}}
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *{{.MockWrapType}}, options ...Option) (bool, []*{{.FQObjectType}}, error)
	{{- end -}}
	{{- if .KeyIsZonal}}
	ListHook   func(ctx context.Context, zone string, fl *filter.F, m *{{.MockWrapType}}, options ...Option) (bool, []*{{.FQObjectType}}, error)
	{{- end}}
	{{- end -}}
	{{- if .GenerateInsert}}
	InsertHook func(ctx context.Context, key *meta.Key, obj *{{.FQObjectType}}, m *{{.MockWrapType}}, options ...Option) (bool, error)
	{{- end -}}
	{{- if .GenerateDelete}}
	DeleteHook func(ctx context.Context, key *meta.Key, m *{{.MockWrapType}}, options ...Option) (bool, error)
	{{- end -}}
	{{- if .AggregatedList}}
	AggregatedListHook func(ctx context.Context, fl *filter.F, m *{{.MockWrapType}}, options ...Option) (bool, map[string][]*{{.FQObjectType}}, error)
	{{- end}}
	{{- if .ListUsable}}
	ListUsableHook   func(ctx context.Context, fl *filter.F, m *{{.MockWrapType}}, options ...Option) (bool, []*{{.FQListUsableObjectType}}, error)
	{{- end}}

{{- with .Methods -}}
{{- range .}}
	{{.MockHook}}
{{- end -}}
{{- end}}

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

{{- if .GenerateGet}}
// Get returns the object from the mock.
func (m *{{.MockWrapType}}) Get(ctx context.Context, key *meta.Key, options... Option) (*{{.FQObjectType}}, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...);  intercept {
			klog.V(5).Infof("{{.MockWrapType}}.Get(%v, %s) = %+v, %v", ctx, key, obj ,err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("{{.MockWrapType}}.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.To{{.VersionTitle}}()
		klog.V(5).Infof("{{.MockWrapType}}.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code: http.StatusNotFound,
		Message: fmt.Sprintf("{{.MockWrapType}} %v not found", key),
	}
	klog.V(5).Infof("{{.MockWrapType}}.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}
{{- end}}

{{- if .GenerateList}}
{{if .KeyIsGlobal -}}
// List all of the objects in the mock.
func (m *{{.MockWrapType}}) List(ctx context.Context, fl *filter.F, options... Option) ([]*{{.FQObjectType}}, error) {
{{- end -}}
{{- if .KeyIsRegional -}}
// List all of the objects in the mock in the given region.
func (m *{{.MockWrapType}}) List(ctx context.Context, region string, fl *filter.F, options... Option) ([]*{{.FQObjectType}}, error) {
{{- end -}}
{{- if .KeyIsZonal -}}
// List all of the objects in the mock in the given zone.
func (m *{{.MockWrapType}}) List(ctx context.Context, zone string, fl *filter.F, options... Option) ([]*{{.FQObjectType}}, error) {
{{- end}}
	if m.ListHook != nil {
		{{if .KeyIsGlobal -}}
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...);  intercept {
			klog.V(5).Infof("{{.MockWrapType}}.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
		{{- end -}}
		{{- if .KeyIsRegional -}}
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...);  intercept {
			klog.V(5).Infof("{{.MockWrapType}}.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
		{{- end -}}
		{{- if .KeyIsZonal -}}
		if intercept, objs, err := m.ListHook(ctx, zone, fl, m, options...);  intercept {
			klog.V(5).Infof("{{.MockWrapType}}.List(%v, %q, %v) = [%v items], %v", ctx, zone, fl, len(objs), err)
		{{- end}}
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		{{if .KeyIsGlobal -}}
		klog.V(5).Infof("{{.MockWrapType}}.List(%v, %v) = nil, %v", ctx, fl, err)
		{{- end -}}
		{{- if .KeyIsRegional -}}
		klog.V(5).Infof("{{.MockWrapType}}.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)
		{{- end -}}
		{{- if .KeyIsZonal -}}
		klog.V(5).Infof("{{.MockWrapType}}.List(%v, %q, %v) = nil, %v", ctx, zone, fl, err)
		{{- end}}

		return nil, *m.ListError
	}

	var objs []*{{.FQObjectType}}
{{- if .KeyIsGlobal}}
	for _, obj := range m.Objects {
{{- else}}
	for key, obj := range m.Objects {
{{- end -}}
{{- if .KeyIsRegional}}
		if key.Region != region {
			continue
		}
{{- end -}}
{{- if .KeyIsZonal}}
		if key.Zone != zone {
			continue
		}
{{- end}}
		if !fl.Match(obj.To{{.VersionTitle}}()) {
			continue
		}
		objs = append(objs, obj.To{{.VersionTitle}}())
	}

	{{if .KeyIsGlobal -}}
		klog.V(5).Infof("{{.MockWrapType}}.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	{{- end -}}
	{{- if .KeyIsRegional -}}
		klog.V(5).Infof("{{.MockWrapType}}.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	{{- end -}}
	{{- if .KeyIsZonal -}}
		klog.V(5).Infof("{{.MockWrapType}}.List(%v, %q, %v) = [%v items], nil", ctx, zone, fl, len(objs))
	{{- end}}
	return objs, nil
}
{{- end}}

{{- if .GenerateInsert}}
// Insert is a mock for inserting/creating a new object.
func (m *{{.MockWrapType}}) Insert(ctx context.Context, key *meta.Key, obj *{{.FQObjectType}}, options... Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...);  intercept {
			klog.V(5).Infof("{{.MockWrapType}}.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
        opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("{{.MockWrapType}}.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code: http.StatusConflict,
			Message: fmt.Sprintf("{{.MockWrapType}} %v exists", key),
		}
		klog.V(5).Infof("{{.MockWrapType}}.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "{{.Version}}", "{{.Resource}}")
	obj.SelfLink = SelfLinkWithGroup("{{.APIGroup}}", meta.Version{{.VersionTitle}}, projectID, "{{.Resource}}", key)

	m.Objects[*key] = &Mock{{.Service}}Obj{obj}
	klog.V(5).Infof("{{.MockWrapType}}.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}
{{- end}}

{{- if .GenerateDelete}}
// Delete is a mock for deleting the object.
func (m *{{.MockWrapType}}) Delete(ctx context.Context, key *meta.Key, options... Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...);  intercept {
			klog.V(5).Infof("{{.MockWrapType}}.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("{{.MockWrapType}}.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code: http.StatusNotFound,
			Message: fmt.Sprintf("{{.MockWrapType}} %v not found", key),
		}
		klog.V(5).Infof("{{.MockWrapType}}.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("{{.MockWrapType}}.Delete(%v, %v) = nil", ctx, key)
	return nil
}
{{- end}}

{{- if .AggregatedList}}
// AggregatedList is a mock for AggregatedList.
func (m *{{.MockWrapType}}) AggregatedList(ctx context.Context, fl *filter.F, options... Option) (map[string][]*{{.FQObjectType}}, error) {
	if m.AggregatedListHook != nil {
		if intercept, objs, err := m.AggregatedListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("{{.MockWrapType}}.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.AggregatedListError != nil {
		err := *m.AggregatedListError
		klog.V(5).Infof("{{.MockWrapType}}.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
		return nil, err
	}

	objs := map[string][]*{{.FQObjectType}}{}
	for _, obj := range m.Objects {
		res, err := ParseResourceURL(obj.To{{.VersionTitle}}().SelfLink)
		if err != nil {
			klog.V(5).Infof("{{.MockWrapType}}.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
			return nil, err
		}
		if !fl.Match(obj.To{{.VersionTitle}}()) {
			continue
		}
        location := aggregatedListKey(res.Key)
		objs[location] = append(objs[location], obj.To{{.VersionTitle}}())
	}
	klog.V(5).Infof("{{.MockWrapType}}.AggregatedList(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}
{{- end}}

{{- if .ListUsable}}
// List all of the objects in the mock.
func (m *{{.MockWrapType}}) ListUsable(ctx context.Context, fl *filter.F, options... Option) ([]*{{.FQListUsableObjectType}}, error) {
	if m.ListUsableHook != nil {
		if intercept, objs, err := m.ListUsableHook(ctx, fl, m, options...);  intercept {
			klog.V(5).Infof("{{.MockWrapType}}.ListUsable(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("{{.MockWrapType}}.ListUsable(%v, %v) = nil, %v", ctx, fl, err)
		return nil, *m.ListError
	}

	var objs []*{{.FQListUsableObjectType}}

	for _, obj := range m.Objects {
		if !fl.Match(obj.To{{.VersionTitle}}()) {
			continue
		}
		{{.Version}}Obj := obj.To{{.VersionTitle}}()
		dest := &{{.FQListUsableObjectType}}{}
		// Convert to Usable type to avoid separate Usable struct
		if err := copyViaJSON(dest, {{.Version}}Obj); err != nil {
			klog.Errorf("Could not convert %T to *{{.FQListUsableObjectType}} via JSON: %v", {{.Version}}Obj, err)
		}
		objs = append(objs, dest)
	}
  klog.V(5).Infof("{{.MockWrapType}}.ListUsable(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}
{{- end}}

// Obj wraps the object for use in the mock.
func (m *{{.MockWrapType}}) Obj(o *{{.FQObjectType}}) *Mock{{.Service}}Obj {
	return &Mock{{.Service}}Obj{o}
}

{{with .Methods -}}
{{- range .}}
// {{.Name}} is a mock for the corresponding method.
func (m *{{.MockWrapType}}) {{.FcnArgs}} {
{{- if .IsOperation }}
	if m.{{.MockHookName}} != nil {
		return m.{{.MockHookName}}(ctx, key {{.CallArgs}}, m)
	}
	return nil
{{- else if .IsGet}}
	if m.{{.MockHookName}} != nil {
		return m.{{.MockHookName}}(ctx, key {{.CallArgs}}, m)
	}
	return nil, fmt.Errorf("{{.MockHookName}} must be set")
{{- else if .IsPaged}}
	if m.{{.MockHookName}} != nil {
		return m.{{.MockHookName}}(ctx, key {{.CallArgs}}, fl, m)
	}
	return nil, nil
{{- end}}
}
{{end -}}
{{- end}}
// {{.GCPWrapType}} is a simplifying adapter for the GCE {{.Service}}.
type {{.GCPWrapType}} struct {
	s *Service
}

{{- if .GenerateGet}}
// Get the {{.Object}} named by key.
func (g *{{.GCPWrapType}}) Get(ctx context.Context, key *meta.Key, options... Option) (*{{.FQObjectType}}, error) {
        opts := mergeOptions(options)
	klog.V(5).Infof("{{.GCPWrapType}}.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("{{.GCPWrapType}}.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "{{.Version}}", "{{.Service}}")

	ck:= &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version: meta.Version("{{.Version}}"),
		Service: "{{.Service}}",
		Resource: key,
	}

	klog.V(5).Infof("{{.GCPWrapType}}.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("{{.GCPWrapType}}.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
{{- if .IsNetworkServices}}
    name := fmt.Sprintf("{{.NetworkServicesFmt}}", projectID, key.Name)
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.Get(name)
{{- else}}
	{{- if .KeyIsGlobal}}
		call := g.s.{{.GroupVersionTitle}}.{{.Service}}.Get(projectID, key.Name)
	{{- end -}}
	{{- if .KeyIsRegional}}
		call := g.s.{{.GroupVersionTitle}}.{{.Service}}.Get(projectID, key.Region, key.Name)
	{{- end -}}
	{{- if .KeyIsZonal}}
		call := g.s.{{.GroupVersionTitle}}.{{.Service}}.Get(projectID, key.Zone, key.Name)
	{{- end}}
{{- end}}
	handleHeaderOptions(&opts, call.Header())
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("{{.GCPWrapType}}.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}
{{- end}}

{{- if .GenerateList}}
// List all {{.Object}} objects.
{{- if .KeyIsGlobal}}
func (g *{{.GCPWrapType}}) List(ctx context.Context, fl *filter.F, options... Option) ([]*{{.FQObjectType}}, error) {
        opts := mergeOptions(options)
	klog.V(5).Infof("{{.GCPWrapType}}.List(%v, %v, %v) called", ctx, fl, opts)
	key := &meta.Key{}
{{- end -}}
{{- if .KeyIsRegional}}
func (g *{{.GCPWrapType}}) List(ctx context.Context, region string, fl *filter.F, options... Option) ([]*{{.FQObjectType}}, error) {
        opts := mergeOptions(options)
	klog.V(5).Infof("{{.GCPWrapType}}.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	key := &meta.Key{Region: region}
{{- end -}}
{{- if .KeyIsZonal}}
func (g *{{.GCPWrapType}}) List(ctx context.Context, zone string, fl *filter.F, options... Option) ([]*{{.FQObjectType}}, error) {
        opts := mergeOptions(options)
	klog.V(5).Infof("{{.GCPWrapType}}.List(%v, %v, %v, %v) called", ctx, zone, fl, opts)
	key := &meta.Key{Name: zone}
{{- end}}
        projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "{{.Version}}", "{{.Service}}")

	ck:= &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version: meta.Version("{{.Version}}"),
		Service: "{{.Service}}",
		Resource: key,
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}

{{- if .KeyIsGlobal}}
	klog.V(5).Infof("{{.GCPWrapType}}.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
{{- if .IsNetworkServices }}
	parent := fmt.Sprintf("projects/%s/locations/global", projectID)
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.List(parent)
{{- else}}
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.List(projectID)
{{- end -}}
{{- end -}}
{{- if .KeyIsRegional}}
	klog.V(5).Infof("{{.GCPWrapType}}.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.List(projectID, region)
{{- end -}}
{{- if .KeyIsZonal}}
	klog.V(5).Infof("{{.GCPWrapType}}.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, zone, fl, projectID, ck)
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.List(projectID, zone)
{{- end}}
{{- if not .IsNetworkServices }}
	if fl != filter.None {
		call.Filter(fl.String())
	}
{{- end}}

	var all []*{{.FQObjectType}}
	f := func(l *{{.ObjectListType}}) error {
		klog.V(5).Infof("{{.GCPWrapType}}.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.{{.ListItemName}}...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("{{.GCPWrapType}}.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

        callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("{{.GCPWrapType}}.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("{{.GCPWrapType}}.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}
{{- end}}

{{- if .GenerateInsert}}
// Insert {{.Object}} with key of value obj.
func (g *{{.GCPWrapType}}) Insert(ctx context.Context, key *meta.Key, obj *{{.FQObjectType}}, options... Option) error {
    opts := mergeOptions(options)
	klog.V(5).Infof("{{.GCPWrapType}}.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("{{.GCPWrapType}}.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

    projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "{{.Version}}", "{{.Service}}")

	ck:= &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version: meta.Version("{{.Version}}"),
		Service: "{{.Service}}",
		Resource: key,
	}
	{{- if .IsNetworkServices}}
	klog.V(5).Infof("{{.GCPWrapType}}.Create(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	{{- else}}
	klog.V(5).Infof("{{.GCPWrapType}}.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	{{- end}}
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("{{.GCPWrapType}}.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name

{{- if .IsNetworkServices}}
	parent := fmt.Sprintf("projects/%s/locations/global", projectID)
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.Create(parent, obj)
	{{- if callOperationRequiresID .Object }}
	  call.{{.Object}}Id(obj.Name)
	{{- end}}
{{- else}}
	{{- if .KeyIsGlobal}}
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.Insert(projectID, obj)
	{{- end -}}
	{{- if .KeyIsRegional}}
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.Insert(projectID, key.Region, obj)
	{{- end -}}
	{{- if .KeyIsZonal}}
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.Insert(projectID, key.Zone, obj)
	{{- end}}
{{- end}}
	call.Context(ctx)

	handleHeaderOptions(&opts, call.Header())
	op, err := call.Do()
	klog.V(4).Infof("{{.GCPWrapType}}.Insert(%v, %v, ...) = %+v", ctx, key, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("{{.GCPWrapType}}.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}
{{- end}}

{{- if .GenerateDelete}}
// Delete the {{.Object}} referenced by key.
func (g *{{.GCPWrapType}}) Delete(ctx context.Context, key *meta.Key, options... Option) error {
        opts := mergeOptions(options)
	klog.V(5).Infof("{{.GCPWrapType}}.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("{{.GCPWrapType}}.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts,  "{{.Version}}", "{{.Service}}")
	ck:= &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version: meta.Version("{{.Version}}"),
		Service: "{{.Service}}",
		Resource: key,
	}
	klog.V(5).Infof("{{.GCPWrapType}}.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("{{.GCPWrapType}}.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
{{- if .IsNetworkServices}}
	name := fmt.Sprintf("{{.NetworkServicesFmt}}", projectID, key.Name)
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.Delete(name)
{{- else}}
	{{- if .KeyIsGlobal}}
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.Delete(projectID, key.Name)
	{{end -}}
	{{- if .KeyIsRegional}}
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.Delete(projectID, key.Region, key.Name)
	{{- end -}}
	{{- if .KeyIsZonal}}
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.Delete(projectID, key.Zone, key.Name)
	{{- end}}
{{- end}}

	call.Context(ctx)

	handleHeaderOptions(&opts, call.Header())
	op, err := call.Do()
	klog.V(4).Infof("{{.GCPWrapType}}.Delete(%v, %v) = %v", ctx, key, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("{{.GCPWrapType}}.Delete(%v, %v) = %v", ctx, key, err)
	return err
}
{{end -}}

{{- if .AggregatedList}}
// AggregatedList lists all resources of the given type across all locations.
func (g *{{.GCPWrapType}}) AggregatedList(ctx context.Context, fl *filter.F, options... Option) (map[string][]*{{.FQObjectType}}, error) {
    opts := mergeOptions(options)
	klog.V(5).Infof("{{.GCPWrapType}}.AggregatedList(%v, %v) called", ctx, fl)

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "{{.Version}}", "{{.Service}}")
	ck:= &CallContextKey{
		ProjectID: projectID,
		Operation: "AggregatedList",
		Version: meta.Version("{{.Version}}"),
		Service: "{{.Service}}",
		Resource: &meta.Key{},
	}

	klog.V(5).Infof("{{.GCPWrapType}}.AggregatedList(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(5).Infof("{{.GCPWrapType}}.AggregatedList(%v, %v): RateLimiter error: %v", ctx, fl, err)
		return nil, err
	}

	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.AggregatedList(projectID)
	call.Context(ctx)
	if fl != filter.None {
		call.Filter(fl.String())
	}
	call.ReturnPartialSuccess(opts.returnPartialSuccess)

	all := map[string][]*{{.FQObjectType}}{}
	f := func(l *{{.ObjectAggregatedListType}}) error {
		for k, v := range l.Items {
			klog.V(5).Infof("{{.GCPWrapType}}.AggregatedList(%v, %v): page[%v]%+v", ctx, fl, k, v)
			all[k] = append(all[k], v.{{.AggregatedListField}}...)
		}
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("{{.GCPWrapType}}.AggregatedList(%v, %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("{{.GCPWrapType}}.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("{{.GCPWrapType}}.AggregatedList(%v, %v) = %v, %v", ctx, fl, asStr, nil)
	}
	return all, nil
}
{{- end}}

{{- if .ListUsable}}
// List all Usable {{.Object}} objects.
func (g *{{.GCPWrapType}}) ListUsable(ctx context.Context, fl *filter.F, options... Option) ([]*{{.FQListUsableObjectType}}, error) {
    opts := mergeOptions(options)
	klog.V(5).Infof("{{.GCPWrapType}}.ListUsable(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "{{.Version}}", "{{.Service}}")
	ck:= &CallContextKey{
		ProjectID: projectID,
		Operation: "ListUsable",
		Version: meta.Version("{{.Version}}"),
		Service: "{{.Service}}",
		Resource: &meta.Key{},
	}
        callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}

	klog.V(5).Infof("{{.GCPWrapType}}.ListUsable(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.ListUsable(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}
	var all []*{{.FQListUsableObjectType}}
	f := func(l *{{.ObjectListUsableType}}) error {
		klog.V(5).Infof("{{.GCPWrapType}}.ListUsable(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("{{.GCPWrapType}}.ListUsable(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("{{.GCPWrapType}}.ListUsable(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("{{.GCPWrapType}}.ListUsable(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}
{{- end}}

{{- with .Methods -}}
{{- range .}}
// {{.Name}} is a method on {{.GCPWrapType}}.
func (g *{{.GCPWrapType}}) {{.FcnArgs}} {
    opts := mergeOptions(options)
	klog.V(5).Infof("{{.GCPWrapType}}.{{.Name}}(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("{{.GCPWrapType}}.{{.Name}}(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
{{- if .IsOperation}}
		return fmt.Errorf("invalid GCE key (%+v)", key)
{{- else if .IsGet}}
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
{{- else if .IsPaged}}
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
{{- end}}
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "{{.Version}}", "{{.Service}}")
	ck:= &CallContextKey{
		ProjectID: projectID,
		Operation: "{{.Name}}",
		Version: meta.Version("{{.Version}}"),
		Service: "{{.Service}}",
		Resource: key,
	}
	klog.V(5).Infof("{{.GCPWrapType}}.{{.Name}}(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("{{.GCPWrapType}}.{{.Name}}(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
	{{- if .IsOperation}}
		return err
	{{- else}}
		return nil, err
	{{- end}}
	}

{{- if .IsNetworkServices}}
    name := fmt.Sprintf("{{.NetworkServicesFmt}}", projectID, key.Name)
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.{{.Name}}(name {{.CallArgs}})
{{- else}}
	{{- if .KeyIsGlobal}}
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.{{.Name}}(projectID, key.Name {{.CallArgs}})
	{{- end -}}
	{{- if .KeyIsRegional}}
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.{{.Name}}(projectID, key.Region, key.Name {{.CallArgs}})
	{{- end -}}
	{{- if .KeyIsZonal}}
	call := g.s.{{.GroupVersionTitle}}.{{.Service}}.{{.Name}}(projectID, key.Zone, key.Name {{.CallArgs}})
	{{- end}}
{{- end}}
{{- if .IsOperation}}
	call.Context(ctx)
	handleHeaderOptions(&opts, call.Header())
	op, err := call.Do()
	klog.V(4).Infof("{{.GCPWrapType}}.{{.Name}}(%v, %v, ...) = %+v", ctx, key, err)

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
        callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("{{.GCPWrapType}}.{{.Name}}(%v, %v, ...) = %+v", ctx, key, err)
	return err
{{- else if .IsGet}}
	call.Context(ctx)
	handleHeaderOptions(&opts, call.Header())
	v, err := call.Do()

        callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("{{.GCPWrapType}}.{{.Name}}(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
{{- else if .IsPaged}}
	var all []*{{.APIGroup}}{{.Version}}.{{.ItemType}}
	f := func(l *{{.APIGroup}}{{.Version}}.{{.ReturnType}}) error {
		klog.V(5).Infof("{{.GCPWrapType}}.{{.Name}}(%v, %v, ...): page %+v", ctx, key, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("{{.GCPWrapType}}.{{.Name}}(%v, %v, ...) = %v, %v", ctx, key, nil, err)
		return nil, err
	}

        callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("{{.GCPWrapType}}.{{.Name}}(%v, %v, ...) = [%v items], %v", ctx, key, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("{{.GCPWrapType}}.{{.Name}}(%v, %v, ...) = %v, %v", ctx, key, asStr, nil)
	}
	return all, nil
{{- end}}
}
{{end -}}
{{- end}}
`
	tmpl := template.Must(template.New("interface").Funcs(template.FuncMap{
		"callOperationRequiresID": callOperationRequiresID,
	}).Parse(text))
	for _, s := range meta.AllServices {
		if err := tmpl.Execute(wr, s); err != nil {
			panic(err)
		}
	}
}

// genTypes generates the type wrappers.
func genResourceIDs(wr io.Writer) {
	const text = `
// New{{.Service}}ResourceID creates a ResourceID for the {{.Service}} resource.
{{- if .KeyIsProject}}
func New{{.Service}}ResourceID(project string) *ResourceID {
	var key *meta.Key
{{- else}}
{{- if .KeyIsGlobal}}
func New{{.Service}}ResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
{{- end}}
{{- if .KeyIsRegional}}
func New{{.Service}}ResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
{{- end}}
{{- if .KeyIsZonal}}
func New{{.Service}}ResourceID(project, zone, name string) *ResourceID {
	key := meta.ZonalKey(name, zone)
{{- end -}}
{{end}}
	return &ResourceID{project, "{{.APIGroup}}", "{{.Resource}}", key}
}
`
	tmpl := template.Must(template.New("resourceIDs").Parse(text))
	for _, sg := range meta.SortedServicesGroups {
		if err := tmpl.Execute(wr, sg.ServiceInfo()); err != nil {
			panic(err)
		}
	}
}

func genUnitTestHeader(wr io.Writer) {
	const text = `/*
Copyright {{.Year}} The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was generated by "go run gen/main.go -mode test > gen_test.go". Do not edit
// directly.

package cloud

import (
	"context"
	"reflect"
	"testing"

	computealpha "{{.AlphaComputePackage}}"
	computebeta "{{.BetaComputePackage}}"
	computega "{{.GaComputePackage}}"

	networkservicesga "{{.GaNetworkservicesPackage}}"
	networkservicesbeta "{{.BetaNetworkservicesPackage}}"

	"{{.FilterPackage}}"
	"{{.MetaPackage}}"
)

const location = "location"
`
	tmpl := template.Must(template.New("header").Parse(text))
	values := map[string]string{
		"Year":                       fmt.Sprintf("%v", time.Now().Year()),
		"FilterPackage":              filterPackage,
		"MetaPackage":                metaPackage,
		"AlphaComputePackage":        alphaComputePackage,
		"BetaComputePackage":         betaComputePackage,
		"GaComputePackage":           gaComputePackage,
		"BetaNetworkservicesPackage": betaNetworkServicesPackage,
		"GaNetworkservicesPackage":   gaNetworkServicesPackage,
	}
	if err := tmpl.Execute(wr, values); err != nil {
		panic(err)
	}
}

func genUnitTestServices(wr io.Writer) {
	const text = `
func Test{{.Service}}Group(t *testing.T) {
	t.Parallel()

	ctx := context.Background()
	pr := &SingleProjectRouter{"mock-project"}
	mock := NewMockGCE(pr)

	var key *meta.Key
{{- if .HasAlpha}}
	keyAlpha := meta.{{.Alpha.MakeKey "key-alpha" "location"}}
	key = keyAlpha
{{- end}}
{{- if .HasBeta}}
	keyBeta := meta.{{.Beta.MakeKey "key-beta" "location"}}
	key = keyBeta
{{- end}}
{{- if .HasGA}}
	keyGA := meta.{{.GA.MakeKey "key-ga" "location"}}
	key = keyGA
{{- end}}
	// Ignore unused variables.
	_, _, _ = ctx, mock, key

	// Get not found.
{{- if .HasAlpha}}{{- if .Alpha.GenerateGet}}
	if _, err := mock.Alpha{{.Service}}().Get(ctx, key); err == nil {
		t.Errorf("Alpha{{.Service}}().Get(%v, %v) = _, nil; want error", ctx, key)
	}
{{- end}}{{- end}}
{{- if .HasBeta}}{{- if .Beta.GenerateGet}}
	if _, err := mock.Beta{{.Service}}().Get(ctx, key); err == nil {
		t.Errorf("Beta{{.Service}}().Get(%v, %v) = _, nil; want error", ctx, key)
	}
{{- end}}{{- end}}
{{- if .HasGA}}{{- if .GA.GenerateGet}}
	if _, err := mock.{{.Service}}().Get(ctx, key); err == nil {
		t.Errorf("{{.Service}}().Get(%v, %v) = _, nil; want error", ctx, key)
	}
{{- end}}{{- end}}

	// Insert.
{{- if .HasAlpha}}{{- if .Alpha.GenerateInsert}}
	{
		obj := &{{.Alpha.APIGroup}}alpha.{{.Alpha.Object}}{}
		if err := mock.Alpha{{.Service}}().Insert(ctx, keyAlpha, obj); err != nil {
			t.Errorf("Alpha{{.Service}}().Insert(%v, %v, %v) = %v; want nil", ctx, keyAlpha, obj, err)
		}
	}
{{- end}}{{- end}}
{{- if .HasBeta}}{{- if .Beta.GenerateInsert}}
	{
		obj := &{{.Beta.APIGroup}}beta.{{.Beta.Object}}{}
		if err := mock.Beta{{.Service}}().Insert(ctx, keyBeta, obj); err != nil {
			t.Errorf("Beta{{.Service}}().Insert(%v, %v, %v) = %v; want nil", ctx, keyBeta, obj, err)
		}
	}
{{- end}}{{- end}}
{{- if .HasGA}}{{- if .GA.GenerateInsert}}
	{
		obj := &{{.GA.APIGroup}}ga.{{.GA.Object}}{}
		if err := mock.{{.Service}}().Insert(ctx, keyGA, obj); err != nil {
			t.Errorf("{{.Service}}().Insert(%v, %v, %v) = %v; want nil", ctx, keyGA, obj, err)
		}
	}
{{- end}}{{- end}}

	// Get across versions.
{{- if .HasAlpha}}{{- if .Alpha.GenerateInsert}}
	if obj, err := mock.Alpha{{.Service}}().Get(ctx, key); err != nil {
		t.Errorf("Alpha{{.Service}}().Get(%v, %v) = %v, %v; want nil", ctx, key, obj, err)
	}
{{- end}}{{- end}}
{{- if .HasBeta}}{{- if .Beta.GenerateInsert}}
	if obj, err := mock.Beta{{.Service}}().Get(ctx, key); err != nil {
		t.Errorf("Beta{{.Service}}().Get(%v, %v) = %v, %v; want nil", ctx, key, obj, err)
	}
{{- end}}{{- end}}
{{- if .HasGA}}{{- if .GA.GenerateInsert}}
	if obj, err := mock.{{.Service}}().Get(ctx, key); err != nil {
		t.Errorf("{{.Service}}().Get(%v, %v) = %v, %v; want nil", ctx, key, obj, err)
	}
{{- end}}{{- end}}

	// List.
{{- if .HasAlpha}}
	mock.MockAlpha{{.Service}}.Objects[*keyAlpha] =  mock.MockAlpha{{.Service}}.Obj(&{{.Alpha.APIGroup}}alpha.{{.Alpha.Object}}{Name: keyAlpha.Name})
{{- end}}
{{- if .HasBeta}}
	mock.MockBeta{{.Service}}.Objects[*keyBeta] =  mock.MockBeta{{.Service}}.Obj(&{{.Beta.APIGroup}}beta.{{.Beta.Object}}{Name: keyBeta.Name})
{{- end}}
{{- if .HasGA}}
	mock.Mock{{.Service}}.Objects[*keyGA] =  mock.Mock{{.Service}}.Obj(&{{.GA.APIGroup}}ga.{{.GA.Object}}{Name: keyGA.Name})
{{- end}}
	want := map[string]bool{
{{- if .HasAlpha}}
		"key-alpha": true,
{{- end}}
{{- if .HasBeta}}
		"key-beta": true,
{{- end}}
{{- if .HasGA}}
		"key-ga": true,
{{- end}}
	}
	_ = want // ignore unused variables.

{{- if .HasAlpha}}{{- if .Alpha.GenerateList}}
	{
	{{- if .Alpha.KeyIsGlobal }}
		objs, err := mock.Alpha{{.Service}}().List(ctx, filter.None)
	{{- else}}
		objs, err := mock.Alpha{{.Service}}().List(ctx, location, filter.None)
	{{- end}}
		if err != nil {
			t.Errorf("Alpha{{.Service}}().List(%v, %v, %v) = %v, %v; want _, nil", ctx, location, filter.None, objs, err)
		} else {
			got := map[string]bool{}
			for _, obj := range objs {
				got[obj.Name] = true
			}
			if !reflect.DeepEqual(got, want) {
				t.Errorf("Alpha{{.Service}}().List(); got %+v, want %+v", got, want)
			}
		}
	}
{{- end}}{{- end}}
{{- if .HasBeta}}{{- if .Beta.GenerateList}}
	{
	{{- if .Beta.KeyIsGlobal }}
		objs, err := mock.Beta{{.Service}}().List(ctx, filter.None)
	{{- else}}
		objs, err := mock.Beta{{.Service}}().List(ctx, location, filter.None)
	{{- end}}
		if err != nil {
			t.Errorf("Beta{{.Service}}().List(%v, %v, %v) = %v, %v; want _, nil", ctx, location, filter.None, objs, err)
		} else {
			got := map[string]bool{}
			for _, obj := range objs {
				got[obj.Name] = true
			}
			if !reflect.DeepEqual(got, want) {
				t.Errorf("Beta{{.Service}}().List(); got %+v, want %+v", got, want)
			}
		}
	}
{{- end}}{{- end}}
{{- if .HasGA}}{{- if .GA.GenerateList}}
	{
	{{- if .GA.KeyIsGlobal }}
		objs, err := mock.{{.Service}}().List(ctx, filter.None)
	{{- else}}
		objs, err := mock.{{.Service}}().List(ctx, location, filter.None)
	{{- end}}
		if err != nil {
			t.Errorf("{{.Service}}().List(%v, %v, %v) = %v, %v; want _, nil", ctx, location, filter.None, objs, err)
		} else {
			got := map[string]bool{}
			for _, obj := range objs {
				got[obj.Name] = true
			}
			if !reflect.DeepEqual(got, want) {
				t.Errorf("{{.Service}}().List(); got %+v, want %+v", got, want)
			}
		}
	}
{{- end}}{{- end}}

	// Delete across versions.
{{- if .HasAlpha}}{{- if .Alpha.GenerateDelete}}
	if err := mock.Alpha{{.Service}}().Delete(ctx, keyAlpha); err != nil {
		t.Errorf("Alpha{{.Service}}().Delete(%v, %v) = %v; want nil", ctx, keyAlpha, err)
	}
{{- end}}{{- end}}
{{- if .HasBeta}}{{- if .Beta.GenerateDelete}}
	if err := mock.Beta{{.Service}}().Delete(ctx, keyBeta); err != nil {
		t.Errorf("Beta{{.Service}}().Delete(%v, %v) = %v; want nil", ctx, keyBeta, err)
	}
{{- end}}{{- end}}
{{- if .HasGA}}{{- if .GA.GenerateDelete}}
	if err := mock.{{.Service}}().Delete(ctx, keyGA); err != nil {
		t.Errorf("{{.Service}}().Delete(%v, %v) = %v; want nil", ctx, keyGA, err)
	}
{{- end}}{{- end}}

	// Delete not found.
{{- if .HasAlpha}}{{- if .Alpha.GenerateDelete}}
	if err := mock.Alpha{{.Service}}().Delete(ctx, keyAlpha); err == nil {
		t.Errorf("Alpha{{.Service}}().Delete(%v, %v) = nil; want error", ctx, keyAlpha)
	}
{{- end}}{{- end}}
{{- if .HasBeta}}{{- if .Beta.GenerateDelete}}
	if err := mock.Beta{{.Service}}().Delete(ctx, keyBeta); err == nil {
		t.Errorf("Beta{{.Service}}().Delete(%v, %v) = nil; want error", ctx, keyBeta)
	}
{{- end}}{{- end}}
{{- if .HasGA}}{{- if .GA.GenerateDelete}}
	if err := mock.{{.Service}}().Delete(ctx, keyGA); err == nil {
		t.Errorf("{{.Service}}().Delete(%v, %v) = nil; want error", ctx, keyGA)
	}
{{- end}}{{- end}}
}
`
	tmpl := template.Must(template.New("unittest").Parse(text))
	for _, sg := range meta.SortedServicesGroups {
		if err := tmpl.Execute(wr, sg); err != nil {
			panic(err)
		}
	}
}

func genUnitTestResourceIDConversion(wr io.Writer) {
	const text = `
func TestResourceIDConversion(t *testing.T) {
	t.Parallel()

	for _, id := range []*ResourceID{
		{{- range .Groups}}
		{{- with .ServiceInfo}}
		{{- if .KeyIsProject}}
		New{{.Service}}ResourceID("my-{{.Resource}}-resource"),
		{{- else}}
		{{- if .KeyIsGlobal}}
		New{{.Service}}ResourceID("some-project", "my-{{.Resource}}-resource"),
		{{- end}}
		{{- if .KeyIsRegional}}
		New{{.Service}}ResourceID("some-project", "us-central1", "my-{{.Resource}}-resource"),
		{{- end}}
		{{- if .KeyIsZonal}}
		New{{.Service}}ResourceID("some-project", "us-east1-b", "my-{{.Resource}}-resource"),
		{{- end -}}
		{{end -}}
		{{end -}}
		{{end}}
	} {
		t.Run(id.Resource, func(t *testing.T) {
			// Test conversion to and from full URL.
			fullURL := id.SelfLink(meta.VersionGA)
			parsedID, err := ParseResourceURL(fullURL)
			if err != nil {
				t.Errorf("ParseResourceURL(%s) = _, %v, want nil", fullURL, err)
			}
			if !reflect.DeepEqual(id, parsedID) {
				t.Errorf("id.SelfLink(%+v) -> ParseResourceURL(%s) = %+v, want original ID", id, fullURL, parsedID)
			}

			// Note that when the NetworkServices API Group was added it meant
			// that the partial paths returned from the functions below that
			// exclude API Group can't be round tripped.

			// Test conversion to relative resource name.
			relativeName := id.RelativeResourceName()
			_, err = ParseResourceURL(relativeName)
			if err != nil {
				t.Errorf("ParseResourceURL(%s) = _, %v, want nil", relativeName, err)
			}

			// Do not test ResourcePath for projects.
			if id.Resource == "projects" {
				return
			}

			// Test conversion to resource path.
			resourcePath := id.ResourcePath()
			_, err = ParseResourceURL(resourcePath)
			if err != nil {
				t.Errorf("ParseResourceURL(%s) = _, %v, want nil", resourcePath, err)
			}
		})
	}
}
`
	data := struct {
		Groups []*meta.ServiceGroup
	}{meta.SortedServicesGroups}
	tmpl := template.Must(template.New("unittest-resourceIDs").Parse(text))
	if err := tmpl.Execute(wr, data); err != nil {
		panic(err)
	}
}

func main() {
	flag.Parse()

	out := &bytes.Buffer{}

	switch flags.mode {
	case "src":
		genHeader(out)
		genStubs(out)
		genTypes(out)
		genResourceIDs(out)
	case "test":
		genUnitTestHeader(out)
		genUnitTestServices(out)
		genUnitTestResourceIDConversion(out)
	default:
		log.Fatalf("Invalid -mode: %q", flags.mode)
	}

	if flags.gofmt {
		fmt.Print(gofmtContent(out))
	} else {
		fmt.Print(out.String())
	}
}
